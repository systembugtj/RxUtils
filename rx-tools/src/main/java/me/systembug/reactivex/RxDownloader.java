package me.systembug.reactivex;

import com.google.common.base.Preconditions;
import com.google.common.base.Strings;

import java.io.File;
import java.io.IOException;
import java.security.InvalidParameterException;

import io.reactivex.ObservableEmitter;
import io.reactivex.ObservableOnSubscribe;
import io.reactivex.annotations.NonNull;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import okhttp3.ResponseBody;
import okio.BufferedSink;
import okio.BufferedSource;
import okio.Okio;
import io.reactivex.Observable;
import io.reactivex.android.schedulers.AndroidSchedulers;
import io.reactivex.schedulers.Schedulers;

/**
 * Created by systembug on 4/12/16.
 */
public class RxDownloader {

    private String mUrl = "";
    private OkHttpClient mOkHttpClient;
    private String mLocal = "";

    public static class Builder {
        private String mUrl = "";
        private OkHttpClient mOkHttpClient;
        private String mLocal = "";

        public Builder client(OkHttpClient client) {
            mOkHttpClient = Preconditions.checkNotNull(client);
            return this;
        }

        public Builder url(String url) {
            mUrl = Preconditions.checkNotNull(url);
            return this;
        }

        public Builder local(String local) {
            mLocal = Preconditions.checkNotNull(local);
            return this;
        }

        public RxDownloader build() {
            return new RxDownloader(mUrl, mOkHttpClient, mLocal);
        }
    }

    private RxDownloader(String url, OkHttpClient client, String local) {
        mLocal = local;
        mOkHttpClient = client;
        mUrl = url;
    }

    public OkHttpClient getOkHttpClient() {
        if (mOkHttpClient == null) {
            mOkHttpClient = new OkHttpClient();
        }
        return mOkHttpClient;
    }

    public Observable<Integer> download() {
        return Observable.create(new ObservableOnSubscribe<Response>() {
            @Override
            public void subscribe(@NonNull ObservableEmitter<Response> emitter) throws Exception {
                if (Strings.isNullOrEmpty(mUrl)) {
                    emitter.onError(new InvalidParameterException("url should be set."));
                    return;
                }
                if (Strings.isNullOrEmpty(mLocal)) {
                    emitter.onError(new InvalidParameterException("local should be set."));
                    return;
                }

                getOkHttpClient().newCall(new Request.Builder().url(mUrl).build()).enqueue(new Callback() {
                    @Override
                    public void onFailure(Call call, IOException e) {
                        emitter.onError(e);
                    }

                    @Override
                    public void onResponse(Call call, final Response response) throws IOException {
                        if (!response.isSuccessful()) {
                            emitter.onError(new IOException("Unexpected code " + response));
                        } else {
                            emitter.onNext(response);
                            emitter.onComplete();
                        }
                    }
                });
            }
        }).flatMap(response -> Observable.create(new ObservableOnSubscribe<Integer>() {
            @Override
            public void subscribe(@NonNull ObservableEmitter<Integer> emitter) throws Exception {
                BufferedSink sink = null;
                try {

                    File file = new File(mLocal);

                    sink = Okio.buffer(Okio.sink(file));

                    int DOWNLOAD_CHUNK_SIZE = 2048;
                    long bytesRead = 0;
                    ResponseBody body = response.body();
                    long contentLength = body.contentLength();
                    BufferedSource source = body.source();

                    while (source.read(sink.buffer(), DOWNLOAD_CHUNK_SIZE) != -1) {
                        bytesRead += DOWNLOAD_CHUNK_SIZE;
                        int progress = (int) ((bytesRead * 100) / contentLength);
                        emitter.onNext(new Integer(progress));
                    }

                    sink.writeAll(source);
                    sink.close();
                } catch (IOException ex) {
                    try {
                        if (sink != null) {
                            sink.close();
                        }
                        emitter.onError(ex);
                    } catch (Exception ignored) {
                        // ignore exceptions generated by close()
                    }
                }

                emitter.onComplete();
            }
        })).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread());
    }
}

